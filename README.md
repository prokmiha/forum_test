# 1. Инструкция по запуску проекта
Этот проект использует Django, Docker, MySQL и Redis. Все зависимости и сервисы описаны в docker-compose.yml.

## 1.1 Требования
- Python 3.10+
- Docker и Docker Compose
- Порт 8000 должен быть свободен (или переопределён вручную)

## 1.2 Переменные окружения
В корне проекта находится файл .env. Он содержит базовые настройки для подключения к базе данных:
```
DB_NAME=forum
DB_USER=forum_user
DB_PASSWORD=forum_pass
DB_HOST=db
DB_PORT=3306
```
Также используется:
```
CELERY_BROKER_URL=redis://redis:6379/0
REDIS_DB=0
```
Если .env отсутствует — создайте по примеру выше.

## 1.3 Сборка и запуск контейнеров
```
docker-compose up --build
```
Это поднимет следующие сервисы:

- db — MySQL
- redis — Redis (кэш, Celery)
- backend — Django-приложение (порт 8000)
- celery_worker — для событийной обработки
- daphne — WebSocket (порт 8001)

## 1.4 Применение миграций
Выполните миграции командой:
```
docker-compose exec backend python forum/manage.py migrate
```
❗️Все миграции уже включены в проект. Выполнять makemigrations не нужно.

## 1.5 (Опционально) Первичная сборка кэша
Если вы хотите вручную собрать\пересобрать кэш для заглавных комментариев (comment:top), можно выполнить:
```
docker-compose exec backend python forum/manage.py shell
>>> from shared.services.comment_cache import CommentCacheService
>>> CommentCacheService.build_top_level_cache()
```
## 1.6 Интерфейс и доступы
- UI: `http://localhost:8000/comment/`
- API: `POST /api/comment/` и `GET /api/comment/`
- WebSocket: `ws://localhost:8001/ws/comments/`

---

# 2. Реализованный функционал

## 2.1 Комментарии (Django + DRF)

Я реализовал API на DRF — для создания и получения комментариев (`POST /api/comment/`, `GET /api/comment/`).  
Поддерживается вложенность любого уровня. Я сохраняю `main_thread`, чтобы потом было проще искать дерево.  
На фронт отправляются заглавные комментарии и до 3 реплаев — остальное можно подгрузить кнопкой "ещё".  
Реализовано через `reply_count`, `has_more_replies`, `depth` — сериализатор собирает нужные поля.  
Новые комментарии правильно вставляются и отображаются благодаря логике в `create()` сериализатора.

## 2.2 Кэширование (Redis)

Сделал два уровня кэша:
- `comment:top` — это заглавные комментарии (до 5000 штук, с головой из первых 100, которые всегда остаются).
- `replies:{parent_id}` — реплаи к любому комментарию.

TTL настроен только для replies (30 минут). Top-level кэш очищается вручную или ротацией.  
Кэш строится при первом запуске и может обновляться при добавлении новых комментов.  
Вся логика централизована в `CommentCacheService.handle_new_comment()` — туда приходит каждый новый комментарий.

## 2.3 CAPTCHA

Сделал простую капчу. Генератор — в `captcha/utils.py`, отображается через модальное окно.  
Картинка обновляется по кнопке, валидация происходит на сервере при отправке комментария.  
Никаких сторонних сервисов — всё локально, через PIL.

## 2.4 Вложения

Поддерживается загрузка файлов до отправки комментария.  
При отправке указываются `attachment_ids`, и вложения привязываются к комментарию.  
Можно удалить вложение до отправки.  
Файлы проходят базовую валидацию по типу и отображаются отдельно.  
API — `/api/attachment/`, всё реализовано через DRF.

## 2.5 XSS-защита

HTML очищается через кастомный `sanitizer.py`.  
Оставлены только разрешённые теги: `<a>`, `<code>`, `<i>`, `<strong>`.  
JS не экранирует HTML, так что фильтрация на сервере — обязательная.  
Я использую `bleach` и `strip_tags` (своей реализацией, без сторонних либ).

## 2.6 WebSocket

Сделал базовую поддержку WebSocket. Используется `daphne`, канал `ws://localhost:8001/ws/comments/`.  
Работает соединение, можно отправлять и принимать сообщения.  
Реальной подписки и динамического обновления пока нет — оставил задел на будущее.

## 2.7 События и логирование

Добавил систему событий через Celery.  
Когда создаётся комментарий, не проходит капча или блокируется HTML — вызывается `emit()` и событие обрабатывается слушателем.  
Есть отдельные файлы под слушатели и таски (`listeners.py`, `tasks.py`) — можно расширять.  
В логике пока только логирование и заглушки под нотификации.

## 2.8 JS и фронтенд

Фронт сделан на чистом JS, без библиотек. Всё разделено по файлам:
- `renderComments`, `commentService`, `attachmentManager` и т.д.  
- Поддержка кнопки "Ответить", "Показать ещё", загрузка файлов, капча.  
- Формы и комментарии отрисовываются динамически, через `fetch()` и шаблонные элементы.  
- Шаблоны: `comment-system.html` + `base.html`. Всё просто и работает.


---

# 3. Нереализованные / отложенные части

## 3.1 Поиск по комментариям

Пока не реализован. В текущей структуре нет сущности, к которой можно было бы привязать комментарии для поиска (например, поста или пользователя). Я примерно представляю, как можно сделать поиск по тексту, но без контекста он будет не очень полезен. Поэтому решил отложить, чтобы не плодить лишнюю логику.

## 3.2 Ограничение вложенности на фронте

Сервер поддерживает вложенность как в ТЗ, но на фронте я не ограничивал глубину. Вложенные реплаи отрисовываются сколько есть. Возможно, это стоило бы ограничить в JS, но я не уверен, как это сделать аккуратно — решил не ломать, пока работает.

## 3.3 JWT и авторизация

JWT не внедрял, потому что авторизации в проекте нет вообще. По ТЗ это не требовалось, и я решил не вводить лишнюю структуру. Если бы понадобилось, я бы начал с DRF авторизации и потом пробовал `simplejwt`, но пока обошёлся без этого.

## 3.4 Graph / GraphDB

Знаю, что в ТЗ был пункт про GraphDB. Я пока не работал с графами и не понял, как именно это нужно было использовать здесь. Возможно, это имелось в виду как способ анализа связей между комментариями, но для тестового решил не усложнять.

## 3.5 Облачный деплой (AWS, GCP и др.)

Проект пока не выложен на облако. Я работаю с VPS, и если будет время, задеплой туда. AWS и другие облака знаю по верхам, но не хотел подключать лишние технологии, в которых пока не уверен. В Docker всё готово для деплоя.

## 3.6 Нагрузочное тестирование и тесты

Автотесты и нагрузочные тесты пока не написал. Честно — не хватает опыта, чтобы уверенно покрыть проект. Возможно, если будет время, я переделаю текущий faker и добавлю хоть какие-то проверки. Пока решил сосредоточиться на логике и кэше.

## 3.7 Защита от гонки при записи кэша

Я не реализовал блокировку при записи в Redis. Кэш просто перезаписывается. Понимаю, что в продакшене это может вызвать проблемы, но решил не лезть в redis-locks и Lua, пока не разобрался с основным механизмом.

